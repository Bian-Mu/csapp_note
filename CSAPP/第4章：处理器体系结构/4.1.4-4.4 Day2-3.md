### Y86-64异常
对于状态码Stat
![[92567bcd3baabce61b42f02b0b01560c.png]]
- ADR：处理器试图读/写非法内存地址
Y86-64在遇到异常时，会停止执行指令，而常规处理器则会调用**异常处理程序**

### Y86-64程序
与x86的区别：
1. 会将常数加载到寄存器，而不是直接在算数中使用
2. 从内存中读值并加到寄存器，会被拆成两步
3. subq指令会同时设置CC（条件码），减少对testq的使用，但因此，要在addq时（即进入循环前）就同样设置CC

### `pushq/popq %rsp`
已知`pushq/popq %xxx`分别会使得%rsp减/加8,并把后面内存器`%xxx`的值写入/弹出内存中，则标题指令到底是写入/弹出原值还是？
>答：原值


### 逻辑设计与硬件控制语言HCL

- 电路的逻辑1/0实现采用1/0V的电压

- 数字系统：
	1. 组合逻辑：计算对位操作的函数
	2. 存储器单元：存储位
	3. 时钟信号：控制存储器单元更新

#### 逻辑门
![[556eb556db7b276f27548cf620a238b8.png]]

#### 组合电路与HCL布尔表达式
将多个逻辑门组合成一个计算块，称为组合电路：
1. 逻辑门的输入必须来自：系统输入（主输入）/存储器单元的输出/逻辑门输出
2. 两个或多个逻辑门的输出不能连接在一起，导致信号矛盾或者电压故障
3. 不出现环（回路）

```
bool XOR = (a&&b)||(!a&&!b)
//异或

bool MUX = (s&&a)||(!s&&b)
//多路复用器，类比三目运算符
```

HCL语言只操作0与1，且不启用部分求值（如c语言中&&会在第一个参数为0时立即返回）

#### 字级组合电路与HCL整数表达式
字在此处大小范围为4～64位![[aeebd08031e6d05253e741160db09f57.png]]
在HCL中，所有字级信号都声明为int,不指定字的大小
```
bool Eq = ( A == B )
```

![[e3b66472edcf9a8a65a9ef839c5a3566.png]]
HCL的选择表达式允许不互斥，且可以依赖s数量的增加，来增加选项数量（2^s的选项数量）

#### 算数/逻辑单元（ALU）
![[e0b16087ad3ca7285ef7572504ec003a.png]]

#### 存储器和时钟
组合电路本质上不存储任何信息，故为了产生时序电路（有状态的组合电路），引入存储设备。
存储设备都是由一个时钟控制的，两类存储设备：
1. 时钟寄存器（寄存器）：存储单个位/字。时钟信号控制寄存器加载输入值
2. 随机访问存储器（内存）：存储多个字，用地址选择要读/写哪个字，
	例如:处理器的虚拟内存系统;寄存器文件（标识符作为地址）

> 关于寄存器：
> 在硬件中，寄存器直接将它的输入和输出线连接到电路的其他部分。
> 在机器级编程中，寄存器代表的是 CPU 中为数不多的可寻址的字，这里的地址是寄存器ID
> 有时候硬件寄存器会直接传送指令，避免先写寄存器再读的延迟

寄存器的输出大多数时候等于它的当前状态X。信号沿着逻辑传播，带来了输入Y,**当时钟从低电压位置变成高电压位置时，信号载入，直到下一次升压前，状态都为Y**
Y86处理器采用时钟寄存器保存PC、CC、Stat![[846428db9b353e5949e1c4f7d4a24001.png]]

#### 典型寄存器文件
![[6f006ea456bd25b64e571222444b56af.png]]
1. 两个读端口A、B，一个写端口W。这样一个多端口随机访问存储器允许同时进行多个读写操作
2. 每个端口都有一个地址输入`src/dst`，表面选择哪个程序寄存器；并且有一个数据输入出`val`
3. 寄存器文件本身不是组合电路，它有内部存储
4. 写入字是由时钟信号控制的，类似于上文说过的“升压”
5. 同时读写同一个程序寄存器的时候，可以看到从旧到新的变化

#### 处理器有一个随机访问存储器来存储数据         
![[c9eb45aa797b15f7cf52f9a2a4c883ba.png]]

### Y86-64的顺序实现

#### 将指令的处理组织成阶段
![[08924be1c4f0057c9f541b64b00c9826.png]]![[6a926a031be96100281702e1f156faa4.png]]
![[c651f1eb6b08721bf802a478eb005e71.png]]


![[301e83d23a5edec57eeaedd453c59979.png]]
ps:valC中存的是立即数D


![[b1b0c29a772e5fc1548fc75a39232044.png]]
ps：在实际惯例里，pushq会先减去8,再写入数据；popq会先取出数据，再加8

控制转移指令：
![[03cbf0205635c4c45bda63917c42228d.png]]


#### SEQ硬件结构
![[cd88e89a1b94096f841b98dc20503ebd.png]]![[71f79b2c0eae0cf5d95daa75faedd6bc.png]]
**剩余部分见书本p274-281，本处看的脑子疼，而且用不到**


### 流水线通用原理
提高了系统的吞吐量，但也会适当增加延迟

**I/O是主存和外部设备之间复制数据的过程。**
Linux系统中，是通过使用内核提供的系统级IO函数来实现诸如printf函数这样的高级IO函数的功能。

### Unix I/O
linux文件就是一个m字节的序列Bi，所有IO设备都可以被模型化为文件，从而可以将输入输出当作文件读写来执行。
通过这种方式，Linux内核可以使用简单的IO接口去处理设备请求。

1. 打开文件：APP要求内核打开“文件”来访问IO设备。内核返回非负整数“描述符”，在后续对此文件的所有操作中标识这个文件。内核记录文件的所有信息，APP只需要记住描述符
2. Linux shell创建的每个进程都有三个打开的文件：
	1. 标准输入（0）
	2. 标准输出（1）
	3. 标准错误（2）
3. 改变文件的位置：每个被打开的文件都有一个位置K，初始为0。该位置K是从文件开头的字节偏移量。APP可以通过seek来显式设置文件的当前位置
4. 读写文件：
	1. 读：从文件中复制第K到K+n个字节到内存中，如果K>=m，则触发EOF
	2. 写：把n个字节复制到文件位置为K的地方，更新K
5. 关闭文件：应用完成对文件的访问后，通知内核关闭该文件。内核会释放文件打开时创建的数据结构，把描述符恢复成“可用”。进程终止时内核会直接关闭所有相关文件

### 文件
每个linux文件都有一个type来表明它的角色：
1. 普通文件（regular file）：包含任意数据。对APP来说，分为文本文件和二进制文件。对内核来说没有区别
2. 目录（directory）：一组包含链接的文件，每个链接将一个文件名映射到一个文件：
	`. ->当前目录； .. ->父目录`
3. 套接字（socket）：用于与另一个进程进行跨网络通信的文件
4. 命名通道、符号链接、字符、块设备

内核将所有文件组织成一个目录层次结构，由根目录`/`确定

- 绝对路径/相对路径

### 打开/关闭文件
#### open函数
![[baf2415d1437038016f063802efca4ba.png]]
![[a4c3761a7c6b0def3e542c1c254e5055.png]]![[74df95ef3a8632a36dce11e668b44d7c.png]]![[6331ba9b24e533316e57e1eabf38db16.png]]![[877227bf30c91264cfb18be18b7c2419.png]]


### 读/写文件
#### read函数
![[2a6cf35b83cab6afce5babc0600979b8.png]]![[5318f66a9fc5bea6c96bc697af31d47d.png]]![[05cd2ccf214498cdd77f3a5c143a83b9.png]]

#### 不足值（传送量小于需求量）
![[caf6335f4032a0d9024b2d5d10ffd795.png]]

### RIO包提供健壮读/写
- 可以自动处理不足值

RIO提供了两种函数：
1. 无缓冲的输入输出函数：直接在内存和文件中传送数据，不受到应用缓冲的影响。常用于网络读写二进制数据
2. 带缓冲的输入函数：允许高效的从文件中读取文本行和二进制数据，文件内容将缓存在应用级缓冲区中（该使用是线程安全的），可以在同一个描述符上交错调用
#### 无缓冲的输入输出函数
##### rio_readn和rio_writen函数
![[ba180bd76986da7952e96006c1397ff5.png]]![[4ea18cc293ff1de224c500309c9c5bf8.png]]![[ced1117a6f75cb41147e7bb23c1dcfc9.png]]

#### 带缓冲的输入函数
##### rio_read、rio_readlineb和rio_readnb函数
![[3550c184a421ae953aba5881f9999140.png]]![[6adb84cba7ddb859f4dc10edf4e72b61.png]]![[6668a656bcf3e206d1ecdde7497c18a0.png]]![[6a1e0be6734963431a0724acee8d069a.png]]![[b7143ea4ed839cd4a978e268845ed8d1.png]]![[d9538bd814685530084303976636726c.png]]![[3d50131aca9c54f55ec68f88bc019fd5.png]]![[eda271c3c0a5d748babf957860f74d15.png]]![[f88118174444a3038c3473e432658f86.png]]![[2a00a74c8500a784dda37b66e2ba97e5.png]]

### 读取文件元数据

元数据：文件的相关信息，APP有时需要访问
#### stat、fstat函数
![[36fcee1300bf15ece19b119ef75b02d5.png]]![[617ec220933a27452b01a093b663752b.png]]![[79b84112274a12329755aa40955eb261.png]]![[f192e3e19e018d45a5f8cbe1524f347d.png]]

### 读取目录内容

APP有时需要访问目录

#### readdir和opendir函数
![[262cd898428eb8f0440c3eb50102db14.png]]![[e1983b4193431da9be698e1412b4a7be.png]]![[0396567f81d8d430ba4bdc97347aa898.png]]![[8b9bc00a4d8ea9475812937b06a67418.png]]

### 共享文件
内核用三个相关的数据结构来表示打开的文件：
1. 描述符表：每个进程独立的描述符表，根据进程打开的文件描述符来索引。每个描述符指向一个表项
2. 文件表：所有进程共享这张表，包含了所有打开文件的集合（文件可以重复），表项中有：当前的文件位置、引用计数（有几条描述符表项指向它）、指向v-node表中表项的指针
3. v-node表：所有进程共享这张表（文件不重复）。每个表项包含了stat中大部分结构（也就是该文件的具体信息）

#### 非共享
![[99769b9a528f3ae4b715dfa2cbbf9311.png]]
#### 共享
##### 进程所指文件文件表条目不同、v-node相同
![[95cb67cb3221731d62aa623c202bc271.png]]
##### 进程所指文件文件表条目相同、v-node相同 
![[8179a253c4c33f393e9f8bcf6afc2612.png]]![[ef7b81476b39df76f08f9b4f1a69dc95.png]]

### I/O重定向
linux允许用户将磁盘文件和标准输入输出联系起来：
`linux> ls>foo.txt`
使得shell加载和执行ls程序，并且输出将会重定向到foo.txt，而不是stdin

#### dup2函数
![[2adf2d11491ce960b7d2b1fce692e442.png]]
- 关闭newfd描述的文件，使得该fd指向的文件变成oldfd，也就是newfd被重定向到oldfd

### 标准I/O
- 诸如printf那样高级的IO函数
- 标准I/O库（例如libc）将一个打开的文件模型化为一个流，也就是一个指向FILE类型的指针
![[bc1f81763cf676763175959d1ce7a605.png]]
- FILE流是对描述符以及流缓冲区的抽象，使得开销比较大的Unix I/O调用次数减少，例如一次性塞满缓冲区，之后多次读取缓冲区而非调用函数

### IO函数们
#### 关联
![[a3bcee4dd8888eb7089a387b4182dfcf.png]]
#### 使用原则
![[3379cc3580b13866031135d2d2ca35ae.png]]

#### 标准I/O的缺陷
![[e2ca2b00c7bd6c56d223e08845245215.png]]
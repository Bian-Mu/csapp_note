### intel Core i7/Linux内存系统分析

#### Core i7地址翻译
1. 结构：
	![[a511bb5a2f08f8c4c1ea6d85ce0c1ba5.png]]
	- QuickPath技术用于实现核与其他核和外部I/O桥直接通信
2. 翻译过程：
	![[be649411f83c35a8286826bc53bd172d.png]]
	- CR3控制寄存器指向第一级页表的起始位置，是每个进程上下文的一部分，上下文切换时CR3的值会恢复
3. 前三层PTE格式（物理页表4KB对齐）：
	![[62db6cb7ce4f7f7eb4054d6ba5f1cc80.png]]
4. 第四层PTE格式（PP4KB对齐）：
	![[b71370eb65a56cf0eff79cda38749815.png]]
	- XD（禁止执行）在64位系统中引入，用于禁止从该内存页中读取指令并执行，可以减少缓冲区溢出攻击的风险
	- A引用位来表示页替换算法
	- D修改位来告诉内核是否需要写回牺牲页
5. 四级页表的翻译（TLB不命中）：
	![[2d4eba60887dc461f3b5ed8e10714932.png]]
	- CR3给出第一层PT基地址，VPN1给出第一层偏移量，第一层PTE给出它管理的第二层PT的基地址...

- （L2->L1）在CPU把VPN发送给MMU的同时，已经将VPO发给L1缓存了，故在MMU在L1TLB中得到PPN时，L1缓存已经完成组索引和字偏移了，可以直接检查标记位

#### Linux虚拟内存系统
- 每个进程都有独立的虚拟地址空间
	![[b572052041f22746303b05a8dd4d382c.png]]
	- 内核虚拟内存中：
		1. 内核代码和数据：全进程共享，例如全局数据结构
		2. 物理内存：内核将**一组连续的VP（大小等于DRAM）映射到一组连续的PP**，允许内核便利的访问物理内存中的任何位置
		3. 其他区域：每个进程专属的数据与结构
1. 区域（area）
	- 区域是已分配的VM的连续chunk，以某种方式相关联，例如`.text`和`.data`等都是区域。**每个已分配的VP都应该属于某个区域**。通过区域的设置，**虚拟地址空间允许存在间隙**
	![[3242d6bcfb0ed709acf9543f62e94f54.png]]
	- 内核的进程独有数据结构中包含了一个`task_struct`，记录了进程所需的所有信息（PID、EXE文件名、PC等）
	- `task_struct`中的`mm_stuct`记录了虚拟内存的当前状态：
		1. `pgd`（在运行时被放在CR3中）：第一级页表的基地址
		2. `mmap`：区域结构链表，**每个结点都描述了一个区域**
			![[721099cf8ab701185114d8c2d5f4778b.png]]
2. 缺页异常后，处理程序的流程：
	1. VA真属于某个区域内吗？处理程序搜索链接，对比起点终点。不合法则返回1（段错误）
		- 链表为树状结构
	2. 有读写/执行该页面的权限吗？不合法则返回2（保护异常）
	3. 该缺页完全合法，选定牺牲页，适当写回，更新PTE，异常处理程序返回，CPU重新发送VA到MMU
	![[9cf5038e80b1b31ec4df9e7c9d886bc3 1.png]]


### 内存映射
内存映射：Linux通过将一个VM区域和一个磁盘上的对象关联起来，来初始化这个VM区域中的内容
对象有两种：
1. Linux文件系统中的普通文件：区域可以映射普通磁盘文件的连续部分（比如一整个EXE）。文件区会被分成页大小的片，每一片可以对应一个VP。当CPU第一次引用时，这些VP才会进入PP。如果区域比文件大，空白部分补0
2. 匿名文件：由内核创建，包含的全是二进制0。CPU第一次引用一个区域的VP时，内核会直接在物理内存中找牺牲页面，可能写回，然后用二进制0覆盖掉这页，更新页表，标记该VP驻留在内存之中。**在这过程中磁盘与内存并没有数据传送，匿名映射是一种将虚拟内存区域映射到物理内存的过程，而不是与实际的文件系统中的文件相关联**

一旦VP完成初始化，将由`swap space`进行维护。任何时刻，`swap space`都限制着当前运行的进程可以分配的VP的总数

#### 共享对象
一个对象被映射到虚拟内存的区域时，要么是共享对象，要么是私有对象
- 共享对象被操作时会直接反映在磁盘的原始对象上，并对其他共享者所见
![[ecacb612083af122453cd731fb395710.png]]
- 每个对象文件名是唯一的，内核可以迅速判断进程1已经映射了该对象，从而使得进程2中的部分PTE也指向该PP。
- 物理内存中只需要存放一份副本

- 私有对象被操作时不会反映在磁盘上
![[f9f4344fbc0ed0a41d8150eff73b6336.png]]
- 私有对象的生命周期与共享对象基本一致，在物理内存中也只有一份副本
- 进程1、2分别映射了同一个私有对象，该相关的PTE被设置为只读，区域结构被设置为**私有的“写时复制”：只要没有进程打算写，多个进程就继续共享；当有进程要写时，触发保护故障**，故障程序在物理内存中创建该页面的新副本，更新该进程的PTE同时修改读写权限，返回CPU,重新执行写操作

#### fork函数
1. 当fork函数被父进程调用时，内核为新进程创建各种数据结构，并分配pid。
2. 为了给子进程分配虚拟内存，创建了当前进程`mm_struct`、区域结构、页表的副本
3. 父子进程中的每个页面都标记为只读，并将两个进程的每个区域结构都标记为私有的“写时复制”
4. 子进程返回时，与父进程调用fork时的虚拟内存相同。
5. 后续不论谁写，都会触发私有的“写时复制”，创建新页面

#### execve函数
- 在当前进程中加载运行参数指向的EXE，有效替代了当前程序
	1. 删除已存在的用户区域：删除当前虚拟地址的用户部分的已存在的区域结构
	2. 映射私有区域：创建新的区域结构。所有新区域都是私有、写时复制的
		![[99236c13b3a818a34cdd8761437daade.png]]
	3. 映射共享区域：如果新程序与共享对象有链接，那么都是动态链接到程序，再映射到用户虚拟地址空间中的共享区域内
	4. 设置PC：设置当前上下文的PC,让它指向代码区域的入口点，下次调度该进程时，将在此执行，根据需要换入代码和数据页面


#### mmap函数实现用户级的内存映射
![[f3953a2f01a1bf702af9fc2568178cd5.png]]
- 内核创建新的虚拟内存区域，尽可能从地址`start`开始，并将文件描述符`fd`所代表的对象的一个连续的chunk映射到该区域，该连续的chunk大小为`length`，从距离文件`offset`处开始映射
![[c73782078df0b9d3c6b11c490dda05ef.png]]
![[b83ce74cd6ff8cae41b5746535be873a.png]]

munmap函数的删除从`start`开始，长度为`length`字节，该部分再次被使用会导致段错误
![[f462f269851add0e7a54746e73eeaf3b.png]]


### 动态内存分配
堆（heap）：动态内存分配器维护一个进程的虚拟内存区域。是一个全为二进制0的区域，在未初始化的区域开始向上增长
![[5505961b7f8788d7e53a853775e89035.png]]
- 对于每个进程，内核维护一个变量`brk`，指向堆顶
- 分配器（allocator）将堆视为一组大小不同的块（block）的集合。每个块都是一个连续的虚拟内存chunk：
	- 已分配的块：显式地保留给程序使用，直到被释放（程序显式执行/分配器隐式执行）
	- 空闲的块：保持空闲，直到被显式的分配
- 分配器类型（都要求应用显式的分配块）：
	1. explicit：显式的释放任何已分配块。例如`malloc/free；new/delete`
	2. implicit：分配器检测到某块将不再被使用时，就释放这个块。隐式分配器也叫垃圾收集器，Lisp,ML,Java等语言采用该方法

#### 显式分配器的设计与实现
##### malloc/free
![[4e96878f8e9a27fae78206058bf8940c.png]]![[a3a6962e8019524702c2e9ec7cfee8ad.png]]
- malloc失败时，会设置errno；不执行初始化
	- malloc的包装函数calloc将内存初始化为0
	- realloc函数可以改变已分配块的大小
- free执行后，虽然空间已经释放，但`*ptr`依然存在，应当不使用
	![[55d19c33d1555d15d7865615dc90d8f7.png]]


![[30e6595d0f42119413ee5454726e35a1.png]]
- sbrk函数通过将内核的`brk`指针增加`incr`来扩展和收缩堆，失败时会把errno设置为ENOMEM
- `incr`可以为负，从而收缩堆

##### 分配器的要求和目标
要求：
1. 处理任意请求序列：free必须在malloc之后，但多个malloc与其对应的free之间的顺序不定
2. 立即响应请求：不允许为了性能重新排列或者缓冲请求
3. 只使用堆：为了满足可扩展性，任何非标量数据结构都必须存在堆里
4. 对齐块：分配器必须对齐块，从而保存任何类型的数据对象
5. 不修改已分配块：分配器只允许操作或者改变空闲块，不允许修改、移动已分配块

目标：
1. 最大化吞吐率：n个分配和释放的一种排列序列Ri，要求单位时间内操作数量n尽可能大
2. 最大化内存利用率：高效的使用虚拟内存
二者相互牵制

##### 碎片
有效荷载：所需字节

- 内部碎片（容易量化）：当已分配块比有效荷载大时。例如为了对齐
- 外部碎片（看未来）：空闲内存加起来足够满足分配请求，但单个空闲块不够。例如需要6个字节，块前4字节、块后2字节，加起来够但依然不能满足分配
分配器通常选择维持少量的大空闲块，而非大量的小空闲块

##### 实现吞吐与利用平衡的分配器
![[061d0f66d341e5fdd139d692c44a2a36.png]]
1. 记录空闲块
2. 放置新分配的块：怎样的空闲块是合适的？
3. 分割空闲块：分配后的剩余部分怎么处理？
4. 合并：如何处理被释放的块？

##### 隐式空闲链表
分配器采用数据结构来区别块的边界、已分配块、空闲块
![[e29a90b4b9e4e5d0bcedf69a7f6c8590.png]]
- 头部(32位)：编码了块大小（头部+载荷+填充）以及是否分配的标识位a。当有双字对齐要求时，块大小一定是8的倍数
	- 编码为：块大小(H)`|`a(H)
- 有效载荷：malloc请求的
- 填充区：满足对齐；满足分配器对付外部碎片等
![[2e32d5655bcc39dd019c7d134e1f6748.png]]
- 头部字段隐含这链接下一个块
- 分配器可以通过遍历所有块获得空闲块的集合
- **最右侧有终止头部，用于标记链表结束**
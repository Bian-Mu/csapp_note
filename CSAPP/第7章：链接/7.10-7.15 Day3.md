### 目标文件3
#### 动态链接共享库
共享库`.so`（也叫共享目标文件）作为一个目标模块，在运行/加载时，可以加载到任意的内存地址，并和内存中的程序链接起来，称为动态链接。这一过程通过动态链接器（本身也是`.so`）执行。

共享库通过两种方式来共享：
1. 任何文件系统，每个库只有一个`.so`文件，所有引用该库的exe共享这个`.so`中的代码和数据，而不是静态库中的复制与嵌入到exe中
2. 在内存中，一个共享库的`.text`节的副本可以被多个不同的正在运行的进程共享
![[a41aa4edd1f63517ebab896adb7dd6c1.png]]
#### 动态链接示例
![[88145e70a2cafb2ffb7652b530ed6403.png]]![[e2a832fc9b1edc76b3c89bf9bb8872cb.png]]

#### 从应用程序中加载和链接共享库
上述所讲是在exe被加载后、执行前时，发生的动态链接。但也会出现运行时要求动态链接

动态链接技术举例：
1. 分发软件：发布新版本共享库，在用户下载后运行程序时，应用将自动链接和加载新的共享库
2. 构建高性能web服务器：许多web服务器生成动态内容，早期依靠fork和execve创建子进程，并在其上下文运行CGI程序来生成动态内容；现代借助动态链接实现
	- 将每个生成动态内容的函数打包在共享库中
	- 当web请求到达时，服务器动态加载和链接合适的函数，直接调用。
	- 函数会一直缓存在服务器的地址空间里，所以只要一个简单的函数调用的开销就可以处理随后的请求了。
	- 在运行时，无需停止服务器，就可以更新存在的函数，添加新的函数

linux动态链接器接口：p487

### 位置无关代码
现代系统通过一种方式来编译共享模块的代码段，使得他们可以**加载到内存的任何位置而无需链接器修改**，从而**允许多个进程共享单一副本**（每个进程的读写数据块不共享）

可以加载而无需重定位的代码称为位置无关代码（PIC），
`gcc -fpic`指示编译系统生成PIC代码，共享库的编译必须有该选项

1. PIC数据引用：
	- 无论在内存何处加载目标模块，数据段和代码段之间的距离总是不变。所以任何变量（数据段中）和任何指令（代码段中）的距离是一个运行时常量，与代码段和数据段的绝对内存位置无关
	- 生成全局变量PIC引用时，编译器在数据段开始的地方创建“全局偏移量表GOT”，在GOT中，每个被这个目标模块引用的全局数据目标（过程或者全局变量）都有一个8字节条目，每个条目都会有一个重定位记录。![[4796e44602a4755023dfbe0bda871c2e.png]]
	- 加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的绝对地址。
	- 每个应用全局目标的目标模块都有自己的GOT
	- 上图中，addcnt定义在当前共享模块中，所以利用距离常量产生直接的PC相对引用，并增加重定位，让链接器在构造该共享模块时解析。如果定义在别的共享模块中，则需要通过GOT间接访问
2. PIC函数调用：
	- 程序调用共享库函数时，编译器无法预测函数的运行时地址。非PIC方法是为该引用生成重定位记录，然后动态链接器在加载时进行解析。
	- PIC函数调用借助了延迟绑定的机制（将过程地址的绑定推迟到第一次调用时），避免了程序只使用小部分共享库函数，而动态链接器加载时解析了所有函数的重定位。
	- 第一次调用过程的运行时开销很大，但之后每次调用都只会花费一条指令和一个简介的内存引用。
	- 延迟绑定依靠GOT和过程链接表（PLT）实现。如果一个目标模块调用定义在共享库中的任何函数，那就会有这两个表。GOT是数据段的一部分，PLT是代码段的一部分![[8ef59c919af1a63de13ab38aa7707407.png]]![[c9597166c59cb1068ac6d8733fff5afb.png]]

### 库打桩机制
- 库打桩：允许截获对共享库函数的调用，取而代之自己的代码。与此同时也可以追踪某些库函数的调用次数，验证输入输出等

基本思想：给定一个需要打桩的目标函数，创建一个包装函数，原型与目标函数一致。通过打桩，可以欺骗系统调用包装函数而非目标函数。包装函数会执行额外的逻辑，然后调用目标函数，最后将目标函数的返回值传给调用者

#### 打桩演示
![[b3df4202b65038b9893b0f6650b66187.png]]
- malloc：从堆中分配一个32字节的块，并返回指向该块的指针
- free：把块还给堆

##### 编译时打桩
- 需要能够访问程序源代码
![[50bb11432a5f3e0528b98aea8a1d77a9.png]]

##### 链接时打桩
- 需要能够访问程序的可重定位对象文件
![[c93ec99db93c1219c5372726efc1be83.png]]![[535d8ddc7c66bf0b388c863173abec47.png]]![[38f072a535ca508130d9cdaf26d2d09c.png]]

##### 运行时打桩
- 只需要能访问exe，基于动态链接器的LD_PRELOAD环境变量
![[a51401e4c43d5673e43a2d87775836af.png]]
![[1cf927bd46c8a60fb3bf5caa087ff7f6 1.png]]
> RTLD_NEXT指的是让链接器从之后的库中寻找（即基础库函数），以便实现原有的功能，因为当前的库环境是传入的LD_PRELOAD（即自制的包装库函数）
### 处理目标文件的工具
![[dee61e41e50beea0d74fa6599efa951a.png]]
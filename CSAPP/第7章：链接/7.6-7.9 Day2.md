### 符号解析
链接器解析符号引用：将每个引用和可重定向目标文件的符号表中已经确定的符号定义相关联

编译器的符号处理
1. 局部符号：只允许每个模块中每个局部符号有一个定义；静态局部变量也有链接器符号，且名字唯一
2. 全局符号：遇到非本模块的符号时，假定为其他模块中定义，生成链接器符号表条目，交给链接器处理，链接器找不到时报错；当多个目标文件出现相同名字的全局符号时，链接器会报错或者采取其中之一

#### 链接器解析多重定义的全局符号
编译器向汇编器输出全局符号时，给每个符号带上“强弱”的标签，汇编器将标签隐藏在可重定位目标文件的符号表里。
> 强：函数、已初始化的全局变量
> 弱：未初始化的全局变量

链接器处理多重定义的全局符号的规则：
1. 不允许多个同名的强符号
2. 一个强符号和多个弱符号同名，选强
3. 多个同名弱符号，任选其一

#### 与静态库链接
所有编译系统都允许：将所有相关目标模块打包成一个单独的文件“静态库”，可以用作链接器的输入。当链接器构造一个输出的可执行文件时，**只复制静态库中被引用的目标模块**

linux中，静态库以一种“存档`.a`”的文件格式存储在磁盘中，是一组连接起来的可重定向目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置

##### 创建与使用静态库
创建：
![[81bd3e087d19394791d07644e5d55a72.png]]
使用：
![[914d829aac2d6f88243f3a06fe3d3f01.png]]

链接器行为：
![[8dffb1fc5ada519f55384e232d0434ce.png]]


#### 链接器使用静态库解析引用
- 符号解析阶段，链接器对命令行参数从左到右扫描`.o/.a`文件（会自动将`.c`翻译成`.o`），扫描时，链接器会维护一个`.o`的集合E，未解析的符号集合U（引用但还没有定义），在前面文件中已定义的符号集合D
1. 命令行参数中的文件f，链接器抉择
	1. `.o->加入E，并且修改U和D`
	2. `.a->匹配U中的符号或者是存档文件成员定义的符号，如果存档文件成员m定义了U中的符号，则会被添加到E中，修改U和D，依次处理.a中的所有成员，直到U和D不再变化，此时对不在E中的成员将被丢弃`
2. 完成所有参数后，如果集合U非空则报错，否则合并和重定位E中的文件，生成exe
3. 如果定义出现在引用之前，会出错：
	![[9f9d3cc20237fbd562d878f5d2cd71a8.png]]
4. 库的一般准则：
	![[396f0bc05d12f0f5884dd09b2db5313b.png]]


### 重定位
完成符号解析后，链接器知道了输入目标模块中的代码节和数据节的确切大小，将合并输入模块，并且为每个符号分配运行地址：
1. 重定位节和符号定义：将所有相同类型的节合并成同一类型的新的聚合节，例如来自不同模块的`.data`被合并成一个`.data`，作为exe的`.data`。链接器将运行时内存地址赋给聚合节、输入模块定义的每个节、输入模块定义的每个符号。这时每条指令与全局变量都有了唯一的运行时内存地址
2. 重定位节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，指向正确的运行时内存地址。这一步要依靠重定位条目

#### 重定位条目
汇编器生成的`.rel.text和.rel.data`，分别存放代码和已初始化数据的重定位条目，指导链接器如何修改引用
![[f419ec5c72a9c76968dbb234080cb010.png]]
- offset：需要被修改的引用的节偏移
- symbol：被修改的引用应该指向的符号
- type：如何修改新的引用
- addend：有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整
	ELF的32种不同的重定位类型：
	1. R_X86_64_PC32：重定位一个使用32位PC相对地址的引用（距离PC当前运行时值的偏移量），CPU在使用PC相对寻址的指令时，在指令编码的32位值加上PC的当前运行时值，得到有效地址，例如callq
	2. R_X86_64_32：重定位一个使用32位绝对地址的引用，CPU直接使用32位值作为有效地址
	- 上述两种类型支持小型代码模型（小于2GB）

#### 重定位符号引用
伪代码：
![[ae0bc6d1a628a3856aea8633862dfcf6.png]]举例计算：
![[aef43a4a5b1f66c6b515505f5a31500a.png]]![[e45204eb5fdbe41915cf6a0b0d9d4dac.png]]![[03dd42f993f2c934294cfbba9f0f33a3.png]]![[925cb9b5868640d4ff789c9f6adcea6a.png]]![[10d7f20449a23d25bc0364da4525a078.png]]


### 目标文件2
#### 可执行目标文件
ELF可执行文件：
![[89e59c13dd2c94c96a8e56059558faee.png]]
- ELF头：描述文件的总体格式，并且包括程序的入口点（运行时第一条指令的地址）
- 已经被重定位的节：同时由于完全链接，故不再包含`.rel`相关的节
- `.init`：定义了函数`_init`，程序的初始化代码会调用它
- 段头部表：描述了exe的连续片段（chunk）与连续内存段之间的映射关系
	![[b9f555bf72b359d0dc890d6289963ac7.png]]![[c87552fe1bfd00de920065cdea6b43cb.png]]


### 加载可执行目标文件

加载：linux调用存储器中的加载器（操作系统代码）来运行exe，加载器将exe的代码和数据从磁盘中复制到内存里，然后跳转到入口点来运行

运行时内存映像：
![[e26a152f53e7216a2f7fe3b687108d96.png]]
- linux-x86_64中，代码段总是从0x400000开始，后面是数据段
- 运行时堆在数据段之后，通过调用malloc库向上增长
- 堆后保留有共享模块
- 用户栈总是从最大的合法用户地址开始（2^48-1），向下递减
- 从栈往上的区域（2^48）开始，是为内核中的代码和数据保留的（操作系统驻留在内存的部分）
- `.data`有对齐要求，所以实际上代码段和数据段有空隙
- 分配栈、共享库、堆这些段的运行地址时，链接器会使用地址空间布局随机化（ASLR），改变每次运行的地址，但相对位置不会改变

加载器工作：
1. 创建如上图的内存映像
2. 借助程序头部表的引导，加载器将exe的片段（chunk）复制到代码段和数据段
3. 跳转到入口点，也就是`_start`函数的地址（在`ctrl.o`中定义）
4. `_start`调用系统启动函数`__libc_start_main`（在`libc.so`中定义）
5. `__libc_start_main`初始化环境，调用用户层的`main`函数，处理返回值，并在需要时将控制权还给内核
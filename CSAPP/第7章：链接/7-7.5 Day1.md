（本章节基于x86-64系统下的linux环境，使用标准的ELF目标文件格式）

### 编译器驱动程序
大多数编译系统提供编译器驱动程序（compiler driver），在用户需要时调用语言预处理器、编译器、汇编器、链接器
![[f9b3e675bd863680adb9a0523100c049.png]]
从ASCII->executable program：
1. C预处理器（cpp）：`.c->.i`
2. C编译器（ccl）：`.i->.s`
3. 汇编器（as）：`.s->.o`
4. 链接器（ld）：`.o->exe`

运行：当输入`./program`时，shell会调用名为加载器的函数（loader），将program中的代码和数据复制到内存，并将控制转移到程序开头

### 静态链接
- ld这样的静态链接器，以一组`可重定位.o`和`命令行参数`为输入，生成`可以完全链接、加载和运行的exe`为输出。
- `可重定位.o`由代码和数据节组成。每节都是连续的字节序列。指令、已初始化全局变量、未初始化全局变量分别属于不同节

链接器主要任务：
1. 符号解析：`.o`定义和引用了符号，每个符号对应于一个函数/全局变量/静态变量。符号解析将符号的引用与定义关联起来
2. 重定位：编译器与汇编器（`.i->.s->.o`）生成从地址0开始的代码和数据节。链接器需要把符号定义与每个地址相对应，从而让符号引用可以指向该内存地址。链接器使用汇编器产生的重定位条目中的详细指令，可以不加检验的执行重定位

### 目标文件
形式：
1. 可重定位：包含二进制代码和数据，可以与其他同类结合创建exe
2. 可执行：包含二进制代码和数据，可以直接被复制到内存中并且执行
3. 共享目标文件：特殊的可重定位，可以在加载或者运行的时候被动态的加载到内存并且链接

各种系统的目标文件格式：
- unix：a.out
- windows：PE
- mac：mach-o
- 现代unix/linux：ELF

#### 可重定位目标文件
![[136c71d393dd0b98a045cac4b2ece29b.png]]
- ELF头：以一个16字节的序列开始，描述了生成该文件的系统的字的大小和字节顺序
- 节头部表：描述了不同节的位置和大小，其中每个节都有一个固定大小的条目，包含文件偏移、条目的大小数量这几个部分 
- 剩余部分：包含帮助链接器进行语法分析和解释目标文件的信息，其中包括ELF头的大小、目标文件的类型、机器类型
	每个节的详细用途：![[cf37197a4e74a9173791a72779c91e16.png]]![[710baf1b728c79dc5bbc234f96f5e07c.png]]

### 符号和符号表
每个可重定位目标模块m都有一个符号表，包含了m定义与引用符号的信息。
1. 全局符号：由模块m定义，可以被其他模块引用。对应于非静态的C函数与全局变量
2. 外部符号（也是全局符号）：由其他模块定义，并且被m模块引用。对应于在其他模块中的非静态的C函数与全局变量
	- 静态函数指的是非extern的函数，即不允许在本文件外调用
3. 局部符号：只能由模块m定义和引用。对应于静态的C函数和全局变量，在m的任何位置都可见，但不能被其他模块引用

符号表由汇编器构造：
![[b37c9d94565576c180f6079aec64025b.png]]
- name：字符串表中的字节偏移，指向符号以null结尾的字符串名字
- value：符号的地址。
	1. 对于可以重定向的模块来说，value是距定义目标的节的起始位置的偏移
	2. 对于可执行文件来说，是一个绝对运行时地址
- size：目标文件的大小
- type:数据或者函数
- binding：指示符号是本地的还是全局的
- section：每个符号所属的目标文件的节，是一个到节头部表的索引
	有三个特殊的伪节（只存在于可重定向目标文件中）：
	1. ABS：代表不该被重定位的符号
	2. UNDEF：未定义的符号，即本模块中有所引用，但是在其他地方定义
	3. COMMON：还未被配置的未初始化的数据目标，value给出对齐要求，size给出最小的大小![[5b6abc909c3376aedd62cdf499596c85.png]]

![[02b1df30c14b49eb3312f8cea6e366b4.png]]
![[2c7383cc41c4784878963c7dcc382d42.png]]
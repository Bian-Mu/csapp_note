### 有符号与无符号数之间的转换
不改变x的二进制位的值，只是改变了解释方式
- 非负数，不变
- 负数，“符号位”被解释成“数值位",满足等式`|T2U(x)|+|U2T(x)|=2^w`


> c语言中遇到x(有符号)与y(无符号)进行运算时，会隐式的将x转化成无符号数，并假定为非负数
> 此时在遇到“>”与“<”时会出现问题


### 扩展数字的位表示

1. 将无符号数转换成更大的数据类型：前面补0,”零扩展“
2. 将补码数字转化成更大的数据类型：前面补最高有效数字，”符号扩展“ 
		例如[111]与[1111]的有符号大小，都是”-1“
		原理：补了`-2^w`，但是一开始的`-2^(w-1)`变成了正的，与一开始的`-2^(w-1)`大小一样

### 截断数字

指代从w位变成k位
1. 截断无符号数：大小变成`x mod 2^k`
		原理：截断的都是2^i,其中i>=k,所以被截断的数`mod 2^k`都为0
2. 截断补码数字：大小变为`U2T(x mod 2^k)`,即将上一步得到的结果视为无符号数，并将最高有效位的值重新考虑，如`U2T(1010)`应该为`-6`


### 无符号数加法

当`0<=x,y<2^w`时，x+y的结果如果溢出，只保留w位，丢弃了最高有效位`1`，此时值变成`x+y mod 2^w`，也就是减去`2^w` **此时就是模加法**
>如果两无符号数相加反而比原数小，则发生溢出

### 补码加法
同上，但是分为
1. 正溢出：`x+y-2^w` 变成负数
2. 负溢出：`x+y+2^w` 变成正数
 也可以表示为`U2T(x+y mod 2^w)`
>当两正数相加为负，则是正溢出，反过来是负溢出

### 补码的非
 ![[98bccdba1b2404ba5d489b86021220b3.png]]
 补码非的计算方式：
 1. **取反后加一**，对于任意整数x,都有`-x=(～x)+1`，例如：0xfffffffa（0x00000006）是-6的补码表示。
 2. 假设k是最右边的1的位置，那么只要**对k左边所有位取反即可**


### 无符号乘法
`(x·y mod 2^w)`

### 补码乘法
`U2T(x·y mod 2^w)`
### 存储器层次结构
![[cc29685641ad3163e84c37acb58feca8.png]]

#### 存储器结构层次中的缓存
##### 中心思想
- 位于k层的更快更小的存储设备会作为k+1层更大更慢的存储设备的缓存；
- k层的缓存中的块是k+1层的块的子集的副本；
- 数据以块大小进行复制传送的；
- 相邻层次的块大小固定，但其他层之间块大小不定；
- 为了补偿低层次访问时间长的情况，会倾向于传送较大的块
![[c6f64434885df5174a17306ca2058cff.png]]

##### 缓存
1. 缓存命中：需要k+1层的块d，先在k层找d，找到就是命中
2. 缓存不命中：k层的缓存会从k+1层的缓存中找到d进行复制，如果已满则覆盖现存的某个块，覆盖的过程由缓存的替换策略控制。复制后就可以从k层读取d了
3. 不命中的分类：
	1. 强制不命中/冷不命中：k层全空
	2. 冲突不命中：相比于随机覆盖，常见的覆盖有k+1层的i块放在k层的i mod 4块中，如0,4,8,12->0。此时如果要请求0,8，则始终无法同时命中这两个块。
	3. 容量不命中：所需处理的工作集太大了，缓存放不下
4. 缓存管理：![[6af544a16939b1a9a3ec203958147550.png]]![[f577074c6bf0d4741d27240556fd784c.png]]

### 高速缓存存储器
#### 通用结构
![[2830c5456abcadfcda278ae19c754947.png]]
- 每个存储器地址有m位，形成2^m个地址
- 有效位指明此行是否包含有意义的信息
- 还有t=m-b-s个标记位，可以唯一标识该块

加载指令指示CPU从地址A中读一个字时，会将地址A发送到高速缓存。如果cache中有A的字的副本，则直接返回。
检查流程：
1. s指示在哪组，**组选择**
2. t指示在哪行（已经设置了有效位并且，标记位与地址A的标记位相匹配），**行匹配**
3. b指示偏移量，**字抽取**
![[2860c0ec570fa4130ac974681aba7a28.png]]
#### 直接映射高速缓存
- **每组只有一行（E=1）**
1. 组选择：
	![[5c6b341577dddaf9c0e779ef2825508e.png]]
2. 行匹配：只有一行
3. 字选择：
	![[fdf861296c06a55fa95d87223f61837a.png]]
4. 不命中时的行替换：
	在下一层中抽取被请求的块，然后存储在s索引指示的组中的一行之中
5. 综合：
	![[fbc228410bb3cd438a64885dfe580888.png]]
6. 冲突不命中：
	![[0ca374a0e1563d5ba349106bbb285d9c.png]]
	![[152d0d116b2d66199cbb1dd448832d9b.png]]
##### 模拟运行
![[a31f88073e0f9032e6e6d607590546c6.png]]
![[fa2e08530bff0565b58e230674a6379f.png]]


#### 组相联高速缓存
- **每组1<E<C/B行**
![[5dfc7ca0d9326e7ab5633cf0c4ee7c49.png]]

1. 组选择
2. 行匹配：
	1. 检查多个行的标记位和有效位以确定是否有字；
	2. 由于组中任何一行都可以包含任何映射到这个组的内存块，所以要对每行进行搜索匹配
3. 字选择
4. 不命中时的行替换：
	1. 不在任何一行中，则向下请求并替换；优先替换空行。
	2. 否则会覆盖，覆盖原则：
		1. 最不常使用（过去某段时间内引用次数最少）
		2. 最近最少使用（距离上一次访问间隔时间最久）
		3. 等等


#### 全相联高速缓存
- **每组C/B行**
![[93f28fd357b13848aed3ec33b1ed453a.png]]

1. 组选择：只有一个组，不需要选择
2. 行匹配：
3. 字选择：
	![[6acb0c98857f9d26dc8dd5f9cf788170.png]]

#### 有关写的问题
上述全是在描述读的操作。
如果我们要**写一个已经缓存的字w**，则：
1. 更新它在缓存中的副本
2. way1->直写：将w的高速缓存块写回下一层
3. way2->写回：尽可能推迟更新，只有当行替换等情况要把这个新w覆盖时，才写回下一层（为此每一行都增加一个额外的修改位）

处理**写不命中**：
1. way1->写分配：加载相应的下一层的块到高速缓存中，然后更新这个缓存块（写回）
2. way2->非写分配：直接写到下一层中（直写）

#### 示例解剖
- **实际上高速缓存不止保存数据，也保存指令**
- 数据缓存 d-cache
- 指令缓存 i-cache
- 双缓存 u-cache（unified）
![[be6c0f7e3a1567ccde4bf936893cba2e.png]]![[be33ae82a63636d08add5f262ea07e00.png]]

#### 性能影响因素
1. 不命中率：不命中数量/引用数量
2. 命中率
3. 命中时间：从高速缓存传送一个字到CPU所需的时间
4. 不命中处罚：由于不命中，导致的额外时间开销
其他影响：
1. 缓存大小：大缓存可以提高命中率；但命中时间会变长
2. 块大小：大块能利用空间局部性，提高命中率；但缓存行数会变小，影响时间局部性，同时不命中处罚也会变大（因为大块传送时间长）
3. 相联度影响：E越大，不容易出现冲突不命中；价格高，标记位增加，命中时间和不命中处罚变大
4. 写策略：
	1. 直写容易实现且能使用独立于高速缓存的写缓冲区，用来更新内存
	2. 写回引起的传送少，节省带宽

### 高速缓存对程序性能的影响

#### 存储器山
读吞吐量与空间局部性的二维函数
![[89a9d559dc05906b65044f5239fb0fef.png]]![[8a669a0409a1445f10c09803ac00106d.png]]

二维矩阵乘法的性能举例：
![[efe9cc6715390f0af32567c048c1df47.png]]
- **kij和ikj版本最快**

1. 内循环
2. 小步长可以最大可能提高空间局部性
3. 连续多次使用数据对象可以提高时间局部性
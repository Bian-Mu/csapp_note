
> 所有信息都是一串bits，区别数据对象的唯一方法是比较上下文（content）

> c语言程序转化成可执行目标文件，并以二进制存储：
> `linux> gcc -o hello hello.c`

### 编译系统

1. 预处理器（cpp）将头文件插入程序，作为`hello.i`
2. 编译器（ccl）将`.i`翻译成汇编语言的`hello.s`
3. 汇编器（as）将`.s`翻译成机器语言指令，打包成“可重定位目标程序”（relocatable object program）的格式，将其保存在`hello.o`
4. 链接器（ld）合并多个`.o` 后得到可执行文件

### 系统硬件组成
![[cacb843699774e9aa44665795130c9ce.png]]
#### 高速缓存存储器（cache memory）
为了解决读取主存与处理器之间的巨大速度差距，使用高速缓存作为近期可能要用的数据的暂时存储区域。
- L1 数万字节
- L2 数十万到数百万字节 速度对L1慢5倍，仍然比主存快5～10倍
> L1与L2使用静态随机访问存储器（SRAM）的技术

三级高速缓存：利用局部性原理，使得程序具有访问局域数据和代码的趋势，存放经常访问的数据，以完成大部分内存操作![[cc29685641ad3163e84c37acb58feca8.png]]
`主要思想：将上一层作为下一层的高速缓存`

### OS管理硬件
作为软件，实现应用程序与硬件的交互

- 文件：对I/O设备的抽象
- 虚拟内存：对主存和磁盘I/O设备的抽象
- 进程：对处理器、主存和I/O设备的抽象

#### 进程
对一个正在运行的程序的抽象，OS的交错执行多个进程被称为上下文切换，CPU看上去在并发执行（不同进程指令是交错执行的）

- 上下文切换：停止保存当前的content、恢复新进程的content，传递控制权
- 上下文切换依靠内核实现，内核接受进程对OS操作的请求，同时进程执行system call把控制权给内核，内核执行后返回进程

##### 线程
一个进程由多个线程组成，每个线程都运行在进程的上下文中，并共享全局数据，多线程比多进程之间更容易共享数据

#### 虚拟内存
为每个进程提供一个“独占主存”的假象，每个进程看到的内存都是一致的“虚拟地址空间”：
![[9569e27d18ccecbc4140f3e3915bdbe4.png]]

#### 文件
字节序列，所有I/O设备都可以看作文件

### 系统之间依靠网络通信
常见的有“服务器——客户端”类型

### Amdahl 定律
当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
若系统执行某应用程序需要时间为Told，假设系统某部分所需执行时间与该时间的比例为a，而该部分性能提升比例为k。即该部分初始所需时间为aToId，现在所需时间Tnew=(aTold)/k。

### 并发和并行
并发：一个同时具有多个活动的系统
并行：用并发来使一个系统运行的更快
1. 线程及并发：
	- 构建在进程的抽象上，设计出同时有多个程序执行的系统。使用线程，甚至可以在一个进程中执行多个控制流。
	- 单处理器依靠任务切换
	- 多处理器：
		1. 多核：多核会共享L3高速缓存与其与主存的接口，每个核都有单独的L1、L2
		2. 超线程/多线程：允许CPU执行多个控制流，它涉及CPU的某些硬件有多个备份，在单个周期的基础上决定要执行哪个线程
2. 指令级并行：
	- 现代处理器可以在单个时钟周期里同时执行多条指令，即使指令需要多个周期（流水线的作用），如果速度比一指令/一周期还要快的话，称为超标量处理器
3. 单指令、多数据并行：
	- 特殊硬件允许一条指令可以产生多个可以并行的操作（SIMD并行），可以提高多模态的执行速度（可以依靠编译器支持的特殊向量数据类型来写程序）

## 抽象
除去内核运行程序外，在应用级中，也有很多并发：
1. 访问慢速I/O设备时让CPU始终繁忙
2. 窗口管理
3. 推迟工作以降低延迟，将简单工作放在空闲周期
4. 服务器一对多
5. 多核处理器并行计算

开发并发程序有三种基本方法：
1. 进程：把每个逻辑控制流当作一个进程，由内核调度维护。由于进程存在独立的虚拟地址空间，所以控制流需要显式的使用进程通信机制
2. I/O多路复用：应用程序在一个进程的上下文中显式的调度逻辑流。逻辑流被视作状态机，当数据到达描述符之后切换状态。程序本身是一个单独的进程，所以这些流共享一个地址空间
3. 线程：是一个单一进程的上下文中的逻辑流，由内核调度。可以理解为进程调度+多路复用的地址空间共享
![[f79b0bfb09458944fbfcb4249fbd3d27.png]]
### 基础echo服务器（迭代版）
![[7c6fe21f2c8a06c6fdc8643ad3d4ced0.png]]
![[9a812cf14bb52f2cf783270de324458d.png]]
![[3885f198ad55934c918e084250b9857d.png]]
![[b39eb5c4329bd857f071a53d524f322f.png]]

### 基于进程的并发编程
- 在父进程中接受客户端的连接请求，创建子进程来为新客户端提供服务

![[ea63b683eef156c6a19f56350f14681d.png]]
- 第二步：子进程获得服务器描述符表的副本；之后要关闭子进程的listenfd、父进程的connfd
![[852b7db0b957ac314ea107a5d6fc4431.png]]
- 第四步：同理

#### 进程并发的echo服务器
![[41e02f1722205df24486293510586eec.png]]
![[1fb7a9928cd8064000268348a8994eb0.png]]
#### 进程的优劣
父子进程共享文件表、但不共享用户地址空间。
独立的空间让进程之间不会覆盖、但共享状态信息变得困难，需要使用显式的IPC（进程间通信）机制
![[3a6f00ef849d6c01b0e44478ab900dc3.png]]

### 基于I/O多路复用的并发编程
- 对于服务器的连接请求、命令行的键盘输入，都需要响应

- 使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后/等待时间过长时，才将控制返回给应用程序

select函数（本书只举例“描述符准备好读”的情况）：
![[7bdb0512d5e304a7c7dc39e99be4d232.png]]
- select函数处理描述符集合（fd_set）类型。该集合可以看作n位的位向量，每个位都对应描述符k。允许做三种事：
	1. 分配描述符集合
	2. 将一个此种类型的变量赋值给另一个变量
	3. 用上述宏定义来修改/检查
- 输入集合与基数
- select函数保持阻塞，直到集合中有一个描述符准备好可以读（从该描述符读取一个字节的请求不再被阻塞）
- select函数修改原指针的指向，让它变成准备好集合，并返回准备好集合的基数
![[3b8b7d9d83c58305c8aeeebfe7a52fbc.png]]
![[3fb37417204afd9a950b7340697888dc.png]]
遗留问题：连接到某个客户端之后，会连续回送输入行，直到客户端关闭connfd，所以从标准输入的命令将不会被响应直到连接结束。
方案：服务器每次循环至多回送一个文本行

#### I/O多路复用并发的事件驱动echo服务器
在事件驱动程序中，某些事件会让流向前推进。考虑将逻辑流转化为状态机。
- 状态机：一组状态、输入事件、转移
	- 转移是指将输入状态和输入事件映射到输出状态
![[ac74973300599acd97c2b1ef5662265b.png]]
- 服务器使用I/O多路复用，借助select函数检测输入事件的发生。当connfd准备好可读时，服务器就为相应的状态机执行转移


![[58a39172eb11e973b5160cffb59fde5f.png]]![[f608fa0c67631158c59bbf7020d55acf.png]]
- pool结构维护这活动客户端的集合
- init_pool初始化pool
	![[4fa4e4a5523cc318c0999c7477729fac 1.png]]
	![[4dcf5e625be43076a09ec5ef2cf93ea3.png]]
- 每次循环中，select函数检测输入：
	1. 新客户端的连接请求，调用add_client函数将客户端加入pool
		![[f3a72af50dbfafe1dc71e5e608291c57.png]]
		![[320d0d538db5cac0b978cfba54302058.png]]
		![[5a4ead5367bca821764ef63ee112a91f.png]]
	1. 已连接客户端的connfd准备好可读
- check_clients函数将每个可读的connfd描述符的一个文本行回送
	![[314ec579a7d056f2a13f6dcc1ce76c62.png]]![[93bd71d99d58666d1c79548bded60949.png]]

根据有限状态机，本例中：
- select函数检测输入事件
- add_client函数创建新的逻辑流/状态机
- check_clients函数回送输入行，执行状态转移，而当客户端完成文本发送后，删除本逻辑流

#### I/O多路并发的优劣
- 对比进程，程序更加可控
- 服务器运行在单一进程的上下文中，每个逻辑流可以访问全部地址空间，共享数据变得容易

- 编码复杂且量大
- 不能充分利用多核处理器
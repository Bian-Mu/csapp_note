### 基于线程的并发编程
线程：运行在进程上下文中的逻辑流，运行在一个进程里的线程共享该进程的整个虚拟地址空间。
线程由内核自动调度，每个线程有自己的上下文，包括线程ID（TID）、栈、栈指针、PC、通用目的寄存器、条件码。

#### 线程执行
![[0790383ab0f7e98749b2a67dbfc86a02.png]]
- 每个线程开始时都是单一的主线程
- 某一时刻主线程创建一个对等线程，此时两个线程开始并发
- 主线程执行慢速系统调用/系统间隔计时器中断，发生进程切换，以此类推

与进程的区别：
1. 上下文更小
2. 上下文切换快
3. 对等线程只和创建它的主线程相关
4. 一个线程可以杀死它的任何对等线程

#### Posix线程
P线程是C语言中处理线程的一个标准接口
![[282b69a61243a1ab27f77b68dca11a6f.png]]![[7f0305d8e24056b7f11600da0caba017.png]]

#### 创建线程
pthread_create函数创建其他线程
![[fa90db4a45775d0d303fe5d4f76fe3fd.png]]
- 创建新线程，带有变量arg
- 新线程的上下文中运行线程例程f
- attr参数来改变新创建线程的默认属性
- 返回时，tid中包含新线程的ID

pthread_self函数获得自己的ID
![[c095076f631f67d00c093156d3b41680.png]]

#### 终止线程
终止情况：
1. 顶层的线程例程返回时，线程隐式终止
2. 对等线程调用pthread_exit函数，显式终止；主线程会等待其他对等线程终止，再终止主线程和整个进程。函数返回值为thread_return
	![[bbb87ae816cf4eecda18e4b4b5d4e21b.png]]
3. 对等线程调用linux的exit函数，该函数终止进程以及相关的线程
4. 对等线程1可以调用pthread_cancel函数（传入当前线程的ID）来终止当前进程
	![[a3d7e1e9a72af35fc5e595496401d580.png]]

#### 回收终止线程
pthread_join函数：
![[7689baed70792ce6f713125eaba4e416.png]]
- 函数阻塞，直到tid终止，将线程例程返回的`void*`赋值为thread_return指向的位置，然后回收内存资源
- 和wait不同，该函数只能等待一个指定的线程

#### 分离线程
在任何时间点上，线程是可结合的/分离的
> 可结合：能够被其他线程收回和杀死，在回收之前不释放内存资源
> 分离：不可被其他线程收回和杀死，内存资源在终止时自动释放

默认情况下，线程是可结合的，对于不被回收的线程，为了避免内存泄漏，需要使用pthread_detach函数主动分离：
![[a80d4830c0aa7e33b1904a42a45d6ea4.png]]
- 可以使用pthread_self()函数获取tid来自我分离

#### 初始化线程
pthread_once函数：
![[136a63e8622d842dcab238f9f3e6e644.png]]
- `once_control`是一个全局/静态变量，第一次被调用时会调用`init_routine`
- 之后被调用时不再做任何事情

#### 基于线程并发的echo服务器
![[0a46d2a0421b0a42b251f8fffb1003ab.png]]![[4b064d1795e2761038b6aa75bf124980.png]]![[055f107b852f7d39bb7ec221fe2e4f78.png]]![[8360853f35643e83ff57b84953e57b4d.png]]

### 多线程程序的共享变量
- 多个线程可以共享相同的程序变量

- 示例程序：
	![[b8377ff311837d6ef868250fd33cb7ec 1.png]]
	- 主线程创建了两个对等线程
	- 主线程传递唯一的ID给每个对等线程
	- 每个对等线程利用ID输出信息以及调用该例程的总次数

#### 线程内存模型
![[e906d242010f07b0bda8ccb2fd2d8898.png]]
#### 变量映射到内存
![[d498cd8d6a0557d3a1779e0ec1373755.png]]

#### 共享变量
![[f863193d6d3d09d59cb16093cefc3433.png]]

### 用信号同步线程
- 变量共享的同时，会出现“同步错误”的情况
	![[6021dc18a43d72a53d05f7b9b4d6e2a1.png]]![[74ad25a6809fa300cf66b28547e44650.png]]
- 错误解析
	![[4ffe61c6ab7c18b75202851dab9d5c9a.png]]![[b6a650381004fff255fc0687b915e592.png]]![[0f9fc24085b823399b8fa310349a840d.png]]

#### 进度图
用进度图表示线程并发的过程
![[04aa86fc825d8cb776f421c78832ece4.png]]![[a40c32223409a0ec962d52952f5b58dd.png]]
- 为了同步线程，让它们总是走安全轨迹（互斥），使用信号

#### 信号量
信号量s：是具有非负整数值的全局变量，只能被以下操作处理：
1. P(s)：如果s非零，s-1并立刻返回；否则，线程挂起直到s变成非零，然后V操作重启该线程，s-1并把控制权给调用者
2. V(s)：s+1。如果有线程在执行P操作且在等待s变成非零（阻塞），则V操作会重启这个线程

PV操作确保了一个正在运行的程序绝不可能出现负信号量

常用函数：
![[be60841da4f215fa80e5fc226eb1e934.png]]![[07d828072de569633e6af1b066a9d4c7.png]]

#### 信号量实现互斥
二元信号量：将共享变量与信号量（初始为1）联系起来，用PV操作将相应的临界区包裹起来，此时s的值只可能是0/1

互斥锁：以互斥为目的的二元信号量，P操作称为加锁、V操作称为解锁。加锁但未解锁的线程称为占用锁
![[3d161cb4594f03320ffa47733d25a9f0.png]]

解决方案：
![[c1e211a0db2cda9e217f1f48f5e94143.png]]

#### 信号量调度共享资源
1. 生产者-消费者问题：
	![[84b2c8bd1013de1e6d1669fc1a1012ef.png]]![[18203fb7062c074cb89f6e0b61eecac1.png]]
- 用SBUF（有限缓冲区）包构建生产消费程序：
	![[24def81ecd67398f18636c7d34d516b3.png]]
	- buf：动态分配的n项整数数组
	- front/rear：数组的第一项和最后一项的索引
	- mutex信号量：提供互斥的缓冲区访问
	- slots信号量：记录空槽位
	- items信号量：可用项目的数量
	![[c40a84f00636fdb002ad04c02f7eb108.png]]
	- sbuf_init函数：为缓冲区分配堆内存，设置各个变量
	- sbuf_deinit函数：APP使用完后，释放缓冲区
	- subf_insert函数：等待一个可用的槽位，对互斥锁加锁，添加项目，解锁，宣告新项目可用
	- sbuf_remove：与subf_insert对称
2. 读者-写者问题：
	![[def0d9d5820cb7ec4be6133781bc5f31.png]]![[9099d42fc8abacc24acbcde66fb61341.png]]![[5d22f625466115cea8e529324a830e04.png]]

#### 基于预线程化并发的echo服务器
![[48f065605db48486637a522eb743ca56.png]]

利用SBUF实现：
![[b621b7d1e55b6fb73e1aab754597dfbc.png]]

![[61fb57371ce3a1de66540c71c3512ff0.png]]![[56aa74966aab7187d144ea3033ef7b75.png]]![[7db0ecd1cd087a54569cf010fa2f5e54.png]]![[23115fc2614dc8288f31671229c7aaa9.png]]


### 使用线程提高并行性
对于多核处理器，OS内核在多个核上并行调度并发线程
![[b55787316fd9334091b48891a1df00eb.png]]

举例多线程并行计算0～n-1：
![[8286ece3eb8537721dbba938e9911377.png]]![[a2971a4205f435410ac4970b8d1195ef.png]]![[58a790d21e4855c858d0fda7a37ca739.png]]

测试结果（四核系统，n=2^31）：
![[91b8d016d0451c896d51ab407f189856.png]]
- 根本原因是PV操作的开销太大![[6c0249aaa1cdaf0c190d56f221f2f39e.png]]![[a4e9a2f0293bf7f81fb242fd9bb79aa5.png]]
- 消除不必要的内存引用![[424df8b43b6a2c71b890d7c43dd43e55.png]]![[87298e43c091a587d8a975a0787f3992.png]]
- 当核内不只有一个线程时，多个线程之间切换上下文也需要开销

### 其他并发问题

#### 线程安全
- 被多个并发线程反复调用时，一直产生正确结果
不安全的函数：
1. 不保护共享变量的函数：例如没有PV函数
2. 保持跨越多个调用的状态的函数：例如伪随机数生成器srand生成的种子，当次结果依赖于前次调用的中间结果，只能重写
3. 返回指向静态变量的指针的函数：例如ctime函数，可能会被其他线程覆盖。
	1. 重写
	2. 使用“加锁-复制”技术：在每次调用时，对互斥锁加锁，将调用返回的结果复制到私有的内存位置，解锁。![[b41f7fa6565b57340108c0c55a632792.png]]
4. 调用线程不安全函数的函数

#### 可重入性
可重入函数：属于线程安全的函数，当被多个线程调用时，不引用任何共享数据（相应的，不需要同步）
![[3c275f47081d971201ad0be6ebd8b9d9.png]]![[360a7acc8cfe64c1bf7007486608cbb9.png]]

如果函数不传递指针，且不使用全局/静态变量，那么它肯定是可重入的，部分指针的数据如果是非共享的，也不会破坏它的可重入性

#### 在线程化程序中使用已存在的库函数
部分库函数是不安全的，常见如下：
![[bf966b935d9e4b8132c11e6980eecabc.png]]

#### 竞争
一个程序的正确性依赖于一个线程要在另一个线程到达y点前到达它控制流中的x点时，就会发生竞争（部分可行的轨迹线最终不能正确运行）![[de6106d4a2fb9ecd861935f47566648c.png]]![[a8fe196caa8c7f2e2d1ed445e04636eb.png]]

消除竞争可以动态为每个TID分配一个独立块，传递给线程一个指向这个块的指针：![[e27b26955f51986d112dab5c87edba60.png]]![[5e44187a75fa7fc5bc8731dfec91fd05.png]]

#### 死锁
死锁：一种运行时错误，当一组线程被阻塞时，等待一个永远不真的条件
![[9e293fa306bfa98be72c10c51cea7e28.png]]![[95cdde19a4218dfbbc1f6b171247c135.png]]


> 避免死锁（互斥锁加锁顺序原则）：给定所有互斥操作一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么该程序无死锁

例如，每个线程中先锁s，再锁t：
![[88780202d92f5552a753f151f2ca769a.png]]
### 算数和逻辑操作

![[3b3a5af7181190f12fbdf2cb48e17b03.png]]

- leaq取起点的值或地址存入终点，并不拘泥于“有效地址”
- `leaq （%rsi,%rdi） %rax`，如果`%rsi %rdi`存的只是值，那最终`%rax`会存储二值之和
> leaq并不引用内存，也就是不读取直接写;此外，leaq的终点必须是寄存器

移位：
	移位量可以是立即数，也可以是存放在`%cl`中，对w位的数据值操作时，虽然编码范围为255，但是实际上移位量由`%cl`的低m位的大小决定（这里2^m=w)

### 特殊运算
#### 64位运算
![[76177f1e06d2d1fefd1e6a8ea9f98556.png]]
固定使用%rdx与%rax来计算，%rdx存储高64位值，%rax存储低64位值
在小端法的条件下，低地址存%rax，高（大）地址存%rdx

对于除法，商存在%rax中，余数存在%rdx中，**上图表有问题**


### 控制
有条件行为的实现：测试数据值，然后根据结果改变控制流或者数据流
![[aa4fc2a208eab3e2da4bb2b0206c254f.png]]
#### 条件码
CPU中有一组单个位的条件码寄存器，用于描述最近的算数/逻辑的属性。
1. CF：进位标志。最近操作使得最高位进位。可用于检查无符号的溢出
2. ZF：零标志。最近操作结果为0。
3. SF：符号标志。最近操作结果为负数。
4. OF：溢出标志。最近操作导致补码溢出。
`只知道一个数，并想要判断正负 可以用test（q/l/...） x a  来达成对x&a的计算，并设置ZF或者SF`
两种指令，只设置条件码而不改变其他任何寄存器
CMP：类比SUB
TEST：类比AND

#### 访问条件码
1. 根据条件码的组合（称为**SET**,后缀不再表示操作数大小,而是条件），将一个字节设置为0/1
	![[5ecd7a395fa6ea777189e80f121e5051.png]]

2. 通过条件跳转到程序的其他部分
3. 有条件的传送数据

#### 跳转指令
会在生成`.o`文件的时候，将跳转目标（目的指令的地址）也编码成跳转指令的一部分
![[1d0536f1b8382185a8b5ffaddbfeb4ce.png]]
条件跳转（除了jmp）只能是直接的

#### 跳转指令的编码
1. PC-relative：使用程序计数器，将目标指令的地址与当前指令的下一句的地址 之间的差作为值来编码，例如下一句的地址是0x3,目标地址在0xA,则PC存的是值0x7，依靠相对地址，可以在不改变编码的情况下允许存储在不同的地址，指令的编码只需要2个字节
AVX浮点体系结构允许数据存储在16个YMM寄存器中，
1. 对标量数据操作时，寄存器只保存浮点数，且只使用低32位/64位![[98f6a7e9a2dc4f2e9a74eb0293b959b9.png]]
2. 以下标量指令（对单个数据值操作）![[5f9d3fe63dda5ec5758a738a924f5768.png]]
3. 向0舍入的截断，把浮点数转换![[e3e957a2f35d3f230cf6d40ce6928718.png]]
4. 转换成浮点数，第二个源只会影响高位字节，常规低位情况下，源2与目的相同![[aaae0b940013b2eb97af22a43ce4197b.png]]
5. 浮点数之间转换![[7f86f8cc7c6f5ce526b59291c429ca9e.png]]![[956c579dcc10516f3d4a79855019a386.png]]


### 过程中的浮点代码
1. XMM 寄存器 %Xmm0~%Xmm7 最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数
2. 函数使用寄存器%Xmm0来返回浮点值。
3. 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

### 浮点数运算
![[23565050903204255f1f76cd51714cc4.png]]

### 定义与使用浮点常数
- 和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间![[c2a3674cb8490c7387ca285bcb9f6cd3.png]]

### 位级操作
![[8ddf9e2a2ab40be253a2c677a2bc1337.png]]
### 浮点比较操作
![[c74387a10cc3d6d2f953dd690c88c64f.png]]
- S2必须在XMM中，而S1可以在XMM或者内存中
- 将会设置3个条件码：
	1. 零标志位ZF
	2. 进位标志位CF
	3. 奇偶标志位PF（当有一方为NaN时为1）
	![[3a49ed2f484192c18e43e6e033802466.png]]


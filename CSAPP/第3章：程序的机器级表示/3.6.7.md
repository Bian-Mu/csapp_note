### 循环
`do-while`
```
loop:
	body-statement 
	t = test-expr;
	if (t) 
		goto loop;
```

`while`
```
1.
	goto test; 
loop : 
	body-statement 
test: 
	t = test-expr; 
	if (t) 
		goto loop;
	
2.	
t = test-expr;
if (!t) 
	goto done; 
do 
	body-statement
	while (test-expr) ;
done: 

3.
t = test-expr; 
if (! t) 
	goto done; 
loop: 
	body-statement 
	t = test-expr; 
	if (t) goto loop;
done:
```

`for`
```
1.
init-expr; 
while (test-expr) { 
body-statement update-exp; 
}

2.
init-expr; 
goto test; 
loop: 
	body-statement 
	update-expr; 
test: 
	t = test-expr; 
	if (t) 
		goto loop;
```


### switch
解决多重分支，使用跳转表（类似数组），当情况多且跨度大时使用
```
static void *jt[index] = {
	&&loc_A, &&loc_B, &&loc_C, &&loc_D, &&loc_def, …… 
};
```
`&&`会创建一个指向代码位置的指针

### 过程

假设有过程P调用过程Q，在Q完成后返回P，则至少包含一个以下的机制：
1. 传递控制。从p->q时，PC会被设置为q的起始地址，返回时，PC设置为p中调用完q后的那条指令的地址
2. 传递数据。p必须向q提供一个或多个参数，q必须向p返回一个值
3. 分配和释放内存。q可能需要为局部变量分配空间，则返回前要释放

#### 运行时栈
p调用q时，控制与数据信息会被添加到栈尾（低地址），返回时释放掉。当所需存储空间超过寄存器大小时，会在栈上分配空间，称为栈帧，大部分栈帧是定长的
> 调用q之后的返回地址在添加q之前被塞到了栈顶（属于p的一部分）

通过寄存器，p可以最多传送6个整数值（指针/整数），如果需要更多，可以事先在自己的栈帧里面存储好这些参数

当局部变量足够少到可以全保存在寄存器中，且函数不会调用任何其他函数，则此时不需要栈帧，该过程可以视作树。

#### 转移控制
设置PC的通过`call`指令实现，call会先将q后一条指令的地址压入栈中，然后把PC设置为q的起始地址，与`call`相对的`ret`会弹出返回地址，并将PC设置为该地址
> `call Label/*Operand`此处目标为q的起始地址

#### 数据传送
寄存器使用顺序
![[d3048a0932e6ccc8872311df38b99c99.png]]
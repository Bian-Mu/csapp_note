### 同步流以避免并发错误
- 多个逻辑流在并发过程中读写同一存储位置的数据/共享数据可能会产生错误

- 竞争示例：
	![[94348da2e4cef8b2555ad256e519b99f.png]]![[4d03ba98b53ea195466b832175cdccee.png]]
	- 解决方法：阻塞信号
	![[cae204b120dcb1edb8ef32b2702b8a44.png]]![[168b580211742db052e7102554c21874.png]]

### 显式的等待信号
- 例如前台作业时，必须等待作业终止才能接收下一条命令
	![[aabe5b284b001ee3b488bd2bf7a85e6c.png]]![[5cd52096a7a450733007758e3327d6af.png]]
	解决等待的浪费问题：
	- sigsuspend函数暂时用mask替换当前阻塞集合，并把进程暂时挂起，等待信号：
	1. 运行处理程序：返回处理程序，恢复原有阻塞集合
	2. 终止：直接结束
	![[1e8e6a9a328fb3a24af318842a7ad3a4.png]]![[8313a93e2afe0c8f12ed31d813067b6c.png]]
	![[18a4ef75f5f2bc82789032d22d2eab86.png]]![[e5ebc11b9e78693839a151f23282e5e2.png]]

### 非本地跳转
- c语言提供一系列用户级异常控制流形式，称为非本地跳转。可以将控制直接从一个函数转移到另一个当前正在执行的函数，不需要遵循：调用->返回序列
1. setjmp函数：
	![[9701ae6a3da6831ad91057de1e4b6be6.png]]
2. longjmp函数：
	![[e21a50e7fec646091ab8e9c724f751f3.png]]

示例1（无视深层嵌套）：
	![[bcc00292e5198c130d31917e943118e9.png]]
	![[9cfdbba8f3945ed3210875718f45bdc6.png]]
示例2（将信号处理程序置于特殊位置）：
	![[50481baf2eb7a835e512b88a526a9685.png]]
	![[8643072e73a0d00337f10032f6475fdd.png]]
	![[fa1cb3e171fc97869582af9232fb38e4.png]]
![[cb27670675ebba5638d3f03fd86bbce4.png]]

### 进程工具
![[e3b79f375487b4bba75a20fd3b2d3886.png]]
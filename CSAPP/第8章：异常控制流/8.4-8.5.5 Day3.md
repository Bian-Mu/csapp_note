### 进程控制
c程序中一系列操作进程的系统调用
#### 获取进程id
- 每个进程都有唯一的正数进程id（pid）
- `getpid`返回pid；
- `getppid`返回父进程的pid
![[ccb9e5dd372f509e137fa8c19126f61e.png]]
#### 创建和终止进程
进程始终处于以下三种状态之一：
1. 运行：要么在cpu上执行，要么在等待被执行且会被内核调度
2. 停止：进程暂时挂起，不接受调度。
	收到以下信号时停止：
	1. SIGSTOP
	2. SIGTSTP
	3. SIGTTIN
	4. SIGTTOU
	收到SIGCONT后再次运行
3. 终止：永远停止
	以下情况会终止程序：
	1. 收到默认行为为终止的信号
	2. 在main中return
	3. 调用exit
![[9d9ebbf2ddae44785452ed82d207dfa9.png]]

##### fork()
- 父进程调用fork函数后会创建新的子进程
![[85066fea7a14081ab4ddd24770ae9cce.png]]
- 子进程拥有与父进程用户级虚拟地址空间相同但独立的副本
- 拥有父进程打开文件描述符相同的副本，可以读写父进程中打开的任何文件
- pid不同
- 子进程的pid=fork()将会为0，**即fork()在子进程中返回0，在父进程中返回子进程的pid**
- fork()调用一次，但返回了两次
![[a54facc7ce64b270ca5aad7091ce3ec3.png]]![[f4d81640c3626000a8c53b382196d4d7.png]]![[8c21db7a951840a02dd92aa4e89dd5b6.png]]

![[dadf1e3d29921047e026c954c875aea3.png]]![[bc760d29906519e34d9e44402d047b53.png]]

##### 子进程回收
- 子进程终止后不会立即清除，而是等待父进程回收。回收后，内核抛弃掉子进程
- 终止但未回收的进程称为僵死进程
- 如果父进程终止时，仍存在子进程，则将`init`进程作为子进程的养父
- `init`进程pid为1，永不终止，是所有进程的祖先
![[97f750032b4e86bfc5bd578c0c49f788.png]]![[22514752b5a81ff2b9044dd276f1c9ef.png]]

![[cd6f8fd76e837631eee66cfc64190de0.png]]
![[8627315277ac2a2bb3237a24d62fa393.png]]![[c85a1e7ffc94f08f5ed4d9b1552fc0a0.png]]


##### 进程休眠
- sleep函数可以让进程暂时挂起
- 时间到后，sleep将返回0，否则返回剩余时间
- pause函数让进程挂起直到收到信号
![[932a78f014bc9ce1fb6beab000150bf2.png]]

##### 加载运行程序
- execve函数在当前进程的上下文中加载运行一个新程序
![[b12746ea9f957e1534ca2d960fbd809e.png]]![[82fcd7b5169357da01e3baa6fbd86949.png]]

- getenv函数获取对应name的value，返回指向value的指针
![[b5e3bfb7cdb9f144fdda342372b5e433.png]]

- setenv函数用于替换一个name的value，但是新value必须非0
- unsetenv函数删除指定name的value
![[d4db559b9d2432b697176597bd309ea7.png]]

#### shell解析输入
- 基础步骤：读值，求值
![[51485a8d21f1660b08e80a970bc0a106.png]]

- 求值过程：
	![[e296784a04b82801fa35346fba257a2a.png]]![[310eb9f5634c7cf90b872b6f7c511fed.png]]![[032f6cbd95f46097b42af3a6c9dc4b69.png]]



### 信号
- 一种信息，通知进程在系统中发生了某件事情
![[04dca60bdbf4864f401eeb2b4204b11d.png]]
- 每个信号都有相对应的事件
- 低层硬件异常交给内核异常处理程序解决，所以用户进程中往往不可见。借助信号，内核可以通知用户进程发生了什么异常

#### 信号术语
传送信号到进程的步骤：
1. 发送信号：内核更新目的进程的上下文中的某个状态来实现发送，可以发送给自己。发送信号可以建立在以下原因上：
	1. 内核检测到系统事件，例如除0、子进程终止
	2. 某个进程调用kill函数，要求内核发送信号到目的进程
2. 接收信号：目的进程被内核强制要求对信号做出某种反应，进程可以忽略信号
	![[3c44a566147739ca47b2906b0f13532d.png]]
	- 待处理信号：发送但没有被接收的信号。
		1. 在任何情况下，同一进程内至多只存在一个k类待处理信号；之后发送的k类信号将会被自动丢弃。
		2. 进程也可以有选择的阻塞某类信号，这类信号可以被发送，但成为待处理信号后会被自动闲置，直到进程取消阻塞。
		3. 每个待处理信号最多只能被接收一次。内核在每个进程的pending位向量中维护着待处理信号的集合，block位向量（信号掩码）中维护着被阻塞的信号的集合。发送k类信号后，pending的第k位会被设置，接收后该位被清除

##### 发送信号
1. 进程组：
	- 所有发送信号的机制都是基于进程组的 
	- 每个进程都只属于一个进程组，进程组由唯一正整数id标识，getpgrp函数可以获取当前进程的进程组id；
		![[c22a1e36c455ff205351e96ffc904d63.png]]
	- 子进程默认与父进程属于同一个进程组，setpgid函数可以改变自己或者其他进程的进程组
		![[01a80c1d90ca9de1df1d2ea613af551a.png]]
		- 如果pid=0，使用当前进程组的pid；
		- 如果pgid=0，使用pid指定的进程的pid作为进程组id
			![[b474e71f40d073e63dd9fff57ed2cef4.png]]
2. `/bin/kill`发送信号
	![[c77bae6b1c06f0aee8da3a53ff1154de.png]]
3. 键盘发送信号
	- 作业（job）：对一条命令行求值而创建的进程，任何时刻最多只有一个前台作业
	![[66905ad554e8dc1caa1ffa38c92624fa.png]]
	- 快捷键：
		![[aa2a347c6003e8418c284efe82df44c5.png]]
4. `kill`函数发送信号
	- 进程可以调用kill函数向其他进程发送信号（包括自己）
	![[c89a896eeec71b53757ea104e9fdc323.png]]
5. `alarm`函数发送信号
	- 进程可以调用alarm函数向自己发送信号
	![[f05294967a6cab085125d2ea47b23dc6.png]]

##### 接收信号
- 当内核把进程从内核模式切换回用户模式时，会检查进程的未被阻塞的待处理信号的集合（`pending&～blocked`）
	1. 集合为空：内核把控制传递给进程的逻辑控制流中的下一条指令
	2. 非空：选择某个最小的信号k（通常是编号最小的），强制进程去接收信号k；进程会根据信号k做出反应，结束后，控制就传回下一条指令
		每个信号类型都有预定义的默认行为（见图8-26）：
		1. 进程终止
		2. 进程终止并转储内存
		3. 进程挂起直到被SIGCONT重启
		4. 进程表示忽略该信号

- signal函数可以修改和信号相关联的默认行为（除了SIGSTOP和SIGKILL）
![[893f70029a1fcb88c3103587ae1b6ee0.png]]
- 当进程捕获了信号k时，会调用为信号k设置的信号处理程序（整数参数被设置为k,参数允许一个函数对应多个k）
- 处理程序执行return时，一般情况下，控制传递回控制流中进程被信号接收导致中断的位置的指令，某些系统中被中断的系统调用会立刻报错
![[1f96cdf8671e7aeb53d61fc95f49e6dc.png]]![[97586bd1d7daec825d5a449db4326b47.png]]

##### 阻塞和解除信号
1. 隐式阻塞机制：当程序处理信号k时，内核默认阻塞k类待处理信号
2. 显式阻塞机制：sigprocmask函数和辅助函数可以明确的阻塞和解除阻塞信号k
	![[37e5a2126d6e851354a9e9444c19916f.png]]

#### 编写信号处理程序

1. 安全的信号处理：
	- 信号处理程序与主程序并发，共享全局变量，可能会和主程序以及其他程序相互干扰
	1. 尽可能简单
	2. 在处理程序中只调用异步信号安全的函数：
		1. 可重入的：只访问局部变量等
		2. 不能被信号处理中断
		![[2f1e9b212625d536f4acd87356a8202d.png]]
	3. 产生安全的输出：使用write函数；使用SIO包来打印简单的信息
		![[e19ebe7c26413fb6f69d0ebb6a654067.png]]![[df766e33468a30e3b68f2ba69d5405b4.png]]
	4. 保存和恢复errno：大部分异步信号安全函数会在出错返回时设置errno，在处理程序中调用这些函数可能会影响其他依赖errno工作的函数。建议进入处理程序时设置局部变量来保存，返回前恢复（如果处理程序最终直接exit，就不需要了）
	5. 阻塞所有信号，保护对共享全局数据结构的访问：如果处理程序与主程序/其他程序共享某个全局数据结构，则应该在访问时暂时阻塞所有信号。因为从主程序访问数据结构的过程中可能被处理程序打断而导致数据结构状态发生变化
	6. 用`volatile`声明全局变量：对于可能被处理程序更新的共享全局变量g，如果main周期性访问g，编译器可能会以为g从未改变而将其放入缓存。该限定符告诉编译器不要放到缓存里，每次都从内存中引用
	7. 用`sig_atomic_t`声明标志：
		![[09712033507f82e7934a318677faafa4.png]]
2. 正确的信号处理：
	- 未处理的信号是不排队的，`pending`位向量中每种类型的信号只有1位，所以每种类型最多只能有一个待处理的信号，则再后来的会被直接丢弃->如果存在未处理信号k，则至少有一个信号到达了
	![[aca5ff3b272e9fc57a915e20c4cf7d4a.png]]![[d77b8f9b2777207e6449345766e0911e.png]]
	![[d018315be10df045cbba4f73c0134838.png]]
3. 可移植的信号处理：
	- 不同的系统有不同的信号处理语义
	1.  使用sigaction函数可以指定信号处理时的语义
		![[d762c540bf3c49f1ba1e9ea15c903091.png]]
	2. 使用sigaction的包装函数Signal
		![[4537eceb805cc66407e276d094c401ce.png]]
		![[6c97240b25b2002ad0fb9b170faa296c.png]]


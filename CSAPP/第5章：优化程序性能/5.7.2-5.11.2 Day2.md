#### 功能单元的性能
![[ab780d1354e6f6a602c43a674ac4e775.png]]
- 发射时间为1的功能单元是完全流水线化的：每个周期都可以开始一个新的运算
- 容量大于一意味着有多个单元
- 除法必须在完成当前运算的全过程之后，再开始下一步
- 吞吐量=容量/发射时间

![[2eeedf49573120ce60a8161f48d7cda0.png]]
- 延迟界限：按照严格顺序完成合并运算的函数所需要的最小的CPE（每元素的周期数）
- 吞吐量界限：CPE的最小界限。例如只有一个单元可以计算整数乘法，故不可能支持每个时钟周期大于1条乘法的速度。相比，有四个功能单元都可以整数加法，理论上CPE为0.25， 但由于只有2个加载单元读取数据值，故为0.5


#### 处理器操作的抽象
##### 机器级代码到数据流图
![[692545486ae75722a3088b7287f28fa8.png]]
对于形成循环的代码，可以把其中的寄存器分类：
1. 只读：不会被修改，如%rax
2. 只写：作为数据传送操作的目的
3. 局部：在循环内部被修改和使用，迭代与迭代之间不相关，如条件码寄存器
4. 循环：既作为源值，又作为目的，迭代值会在另一次迭代用到，如%rdx、%xmm0

![[eaa0f6e16127d645566ff303d7c3c982.png]]![[086cc76a6d74c80808cdd45edf49a93a.png]]
关键路径指会限制操作执行顺序的数据，即其他操作被关键路径制约了

##### 其他性能因素
关键路径只是下界，实际还会出现功能单元数量、传递数据量等影响。
- 对于整数加法，由于数据操作足够快，使得其他操作供应数据不够快，导致CPE比理想要高，故需要调整操作的结果，增强指令并行级
![[7f5739a17e026fe4958a7ea1b4dc01c7.png]]

### 循环展开（kX1）
通过增加每次迭代计算的数量，减少循环迭代的次数：
1. 减少了不直接有助于程序结果的操作的数量，例如循环索引的计算和条件分支
2. 提供了方式，有助于减少关键路径上的操作数量

int i=0；每次计算k步->
1. 第一次循环不超出界限，i<n-(k-1)
2. 每组都不超出界限：此时每组最大索引为i+(k-1)
3. 单独处理余数部分共k-1步，[n-(k-1)，n）
以下示例k=2：
![[d2d8c374c859ac0ef048928adfaec3f6.png]]

循环展开改进了CPE，但始终大于延迟界限，根本原因是关键路径上的mul操作数量仍然是n次
![[342d7cf3c4f063c2824f3fa0a050e850.png]]


### 提高并行性
对于这个单独变量`acc`，在前面的计算完成之前，都是无法计算下一个`acc`的新值，即使计算它的功能单元可以在每个周期开始新的操作，也要遵循合并操作的延迟，故引入并行

#### 多个累积变量（kXk）
例如引入`acc0`和`acc1`，分别计算索引为偶数和奇数的元素的乘积
![[00bda3101481041d2c41ec626231aaa9.png]]![[433196620be94d21ba17368cfc502f00.png]]

- 此时处理器不再受限于延迟界限（分成了两个变量/两个寄存器，这二者间没有数据关联，变成两条关键路径）
![[d26a091b6c78fed2efa0c625648c24c4.png]]![[46303b0b54dfde0ae58922e321843873.png]]
一般，只有当k>容量X延迟时，且流水线满时才能逼近吞吐量界限

**要考虑函数功能是否发生改变**，比如浮点数乘法与浮点数加法由于舍入/溢出的关系，该并行展开会改变计算结果

#### 重新结合变换（kX1a）
![[5c468cf38af9e6107ca0ea485de8eb71.png]]**改变了括号顺序**
![[f2bc95f0e31c7c0896edba490d7941e5.png]]![[9290fa7f0426355ef17a0796c52271bb.png]]
改变了关键路径上的mul次数

#### 向量指令（之前提到的计算是标量环境）
1. 使用向量指令可以有更高的并行度，因为其可以在单个指令周期内对多个数据执行相同的操作（SIMD），比如一个128位的SIMD指令可以同时处理四个32位的整数或浮点数
2. 有效利用内存带宽。SIMD指令加载和存储的是一整个数据块，而不是单一数据点，减少了访问次数
3. 减少总指令数量，可以降低程序大小，减少译码和传送量

伪代码举例：
```
for i from 0 to 999:
    C[i] = A[i] + B[i]

for i from 0 to 999 step 4:
    C[i:i+3] = A[i:i+3] + B[i:i+3]

```


### 其他制约因素
1. 并行度超过了寄存器数量，则编译器其会由于溢出，将某些临时值放到内存里，通常是在运行时堆栈上分配空间（幸运的是寄存器溢出前一般就达到吞吐量上限了）![[291510a6234e82a288f1871df5330418.png]]
	- x86只有16个寄存器，且只有16个YMM寄存器来保存浮点数
	![[81592cd8e7d2b9b2867f88e679168f0a.png]]
2. 在投机执行的处理器中，部分处理器会将条件分支编译成条件传送指令，计算出条件表达式在两个方向上的值，可以被视为普通指令流水线化的一部分
3. 现代处理器其强大的预测能力，不需要过分关心可预测的分支
4. 对于不可预测的测试，需要修改代码风格让编译器更可能翻译成条件传送语句
	![[e1bfcfb589c79fcd4861646fba4c9a3e.png]]



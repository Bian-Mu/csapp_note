 ### 妨碍优化的因素
1. 内存别名使用：两个指针指向同一个地址
2. 函数调用存在副作用，例如改变全局变量

内联函数的优缺点 p345

### 表示程序性能
CPE：每元素的周期数
时钟频率一般为GHz（千兆赫兹）

利用循环展开可以使得循环次数减少（i+=2....循环体内同时操作两次）


### 不依靠机器特性的一些优化
1. 代码移动：对于多次求值但结果不变的计算，让它不再多次求值（移动到循环外）
2. 渐近低效率：（没理解错的话）随着数据量增大而耗时显著增加的部分
3. 减少过程调用：例如多次调用一个可被简单/库函数替代的函数
4. 消除不必要的内存引用：减少寄存器/内存的读写次数，比如反复修改指针解引用的值
	- 内存别名：编译器会假设要处理的内存片段有所重叠，所以会反复读写到内存中


### 理解现代处理器
特点：
1. 指令级并行，同时处理多条指令，但呈现出一种简单的顺序执行的表象
2. 程序性能界限：
	1. 延迟界限：严格按照顺序执行指令
	2. 吞吐量界限：处理器功能单元的原始计算能力

#### 整体操作
处理器设计：
- 超标量：每个时钟周期执行多个操作
- 乱序：执行顺序与程序顺序不一致（复杂度高但指令并行度高）
1. ICU（指令控制单元）：从内存中读出指令序列，并生成一组操作
2. EU（执行单元）：执行操作
![[7877a7e41b034c72e129a3830e633f07.png]]

1. ICU从指令高速缓存中读取指令，取指、译码，并把操作发送给EU（这一过程远早于正在运行的指令；
2. 当遇到分支时：
	1. 可能性一：选择某一分支，控制被传送到该分支
	2. 可能性二：不选择分支，控制被传递到下一条指令
> 分支预测技术：猜测是否选择分支以及预测分支的目标地址。使用“投机执行”（条件/数据满足前，先执行可能要执行的指令）技术，处理器取出分支所跳转的地方的指令，并进行译码。如果过后确认预测错误，则状态重新设置到分支点的状态，并开始取出和执行另一个分支的指令。
3. 标记为**取指控制**的块包括分支预测
4. 指令译码接受实际的程序指令，并转换成一组基本操作（微操作），每个操作都完成某个简单的计算任务，一条指令也可以被译成多个独立的小操作
5. EU接受来自取指单元的操作。通常每个时钟周期会接受多个操作。这些操作被分派到一组功能单元中，执行实际的操作。不同单元作用不同
6. 读写内存由加载和存储单元实现：
	1. 加载单元：从内存读数据到处理器，利用加法器完成地址计算
	2. 存储单元：从处理器写到内存中，也有加法器
	- 二者通过数据高速缓存来访问内存
7. 使用投机执行技术对操作求值，但是最终结果不会被存放到寄存器/内存中，直到处理器能确定应该执行这些指令。分支被传送到EU，不是为了确定要往哪里去，而是要确定预测是否正确（见分支预测技术）
8. 算术运算单元可以执行多种运算，满足了程序运算的多样性
9. 退役单元（RU）记录正在进行的处理，并确保它遵守顺序语义。控制着寄存器的更新，译码时，指令的信息被放置在一个先进先出的队列里，直到
	1. 一条指令的操作完成，而所有引起这条指令的分支点也都被确定预测正确，**则该指令退役，所有寄存器执行更新**
	2. 分支预测错误，该指令清空，丢弃所有计算结果
10. 为了加速指令的结果的传送，许多信息在EU之间交换，即“操作结果”
11. 控制这些操作数在执行单元间传递的机制为“寄存器重命名”：
	1. 当一条更新寄存器r的指令译码时，标记t会被指向该操作的结果（唯一标识符），此时条目（r,t）被加入到表中，该表维护每个r与t的关联
	2. 当以r为操作数的指令译码时，发送到执行单元的操作会包含t作为操作数源的值，当某个执行单元完成第一个操作，产生了结果（v,t），则所有等待t作为源的操作都可以使用v。这是某种形式的数据转发
	3. 重命名表只包含未进行写操作的寄存器条目，当指令需要寄存器r时，而又没有标记时，可以直接从寄存器文件中获取
	4. 即使需要分支结果确认，处理器也可以预测执行单元的整个序列
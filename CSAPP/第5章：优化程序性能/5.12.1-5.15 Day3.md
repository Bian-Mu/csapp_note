### 内存性能
**以下部分只考虑从cache中加载和存储的情况**

#### 加载
之前的测试中，CPE由于只存在2个加载单元，故从未小于0.5，且加载操作的影响比例很小，并不会限制性能（成为关键路径的一部分）

以下示例中，计算链表长度时需要加载每个结点的地址：![[7dc2774c122dbf4a8ff243a96dbdae0f.png]]
该函数CPE为4.0

#### 存储
与加载一样，在先前示例里影响不大

![[eaf8d4fa9ba0fa846273801d00b4f805.png]]
> 存储操作并不影响任何寄存器的值，除了被加载操作读取外，不会产生数据相关
> 而写/读相关（一个内存读的结果依赖于上一次的内存写）会极大增大CPE 
![[a21e96ab3352c9ed2e838bcc811e86b6.png]]
1. 存储单元包含存储缓冲区，其中有已经被发射到存储单元、但没有完成存储操作的地址和数据（包括更新cache）。
2. 当一个加载操作发生时，会访问存储缓冲区，**如果在写和在读的地址相同，则发现了写/读相关**

![[07bae158cf123af3fed01d5917313252.png]]![[f58da2acf882d83287af1d93d7aebb78.png]]
1. 被分成两个部分的mol指令，s_addr部分必须早于s_data
2. load操作会检查所有未完成的存储操作的地址，如果检查到**写/读相关**，则load必须等到s_data将结果放到存储缓冲区中，**如果地址不同，则load（加载）与s_data就可以独立运行）
![[3711793f0ede7f19e91229ef0dc93f71.png]]

故关键路径如下：
![[550ef19ca279a66c4c94321cb17b25c2.png]]


### 程序剖析工具 GPROF
p388